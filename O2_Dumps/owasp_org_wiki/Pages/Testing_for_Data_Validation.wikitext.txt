{{Template:OWASP Testing Guide v3}}

''' 4.8 Data Validation Testing '''
----

The most common web application security weakness is the failure to properly validate input coming from the client or environment before using it. This weakness leads to almost all of the major vulnerabilities in web applications, such as cross site scripting, SQL injection, interpreter injection, locale/Unicode attacks, file system attacks, and buffer overflows.<br>
Data from an external entity or client should never be trusted, since it can be arbitrarily tampered with by an attacker. "All Input is Evil", says Michael Howard in his famous book "Writing Secure Code". That is rule number one. Unfortunately, complex applications often have a large number of entry points, which makes it difficult for a developer to enforce this rule.
<br>
In this chapter, we describe Data Validation testing. This is the task of testing all the possible forms of input to understand if the application sufficiently validates input data before using it.<br>
We split data validation testing into the following categories:<br>

'''Testing for Cross site scripting'''<br>
In Cross Site Scripting (XSS) testing, we test if it is possible to manipulate the input parameters of the application so that it generates malicious output. We find an XSS vulnerability when the application does not validate our input and creates an output that is under our control. This vulnerability leads to various attacks, for example, stealing confidential information (such as session cookies) or taking control of the victim's browser. An XSS attack breaks the following pattern: Input -> Output  == cross-site scripting<br>
In this guide, the following types of XSS testing are discussed in details:<br>
[[Testing for Reflected Cross site scripting (OWASP-DV-001) |4.8.1 Testing for Reflected Cross Site Scripting (OWASP-DV-001) ]]<br>
[[Testing for Stored Cross site scripting  (OWASP-DV-002) |4.8.2 Testing for Stored Cross Site Scripting(OWASP-DV-002) ]]<br>
[[Testing for DOM-based Cross site scripting  (OWASP-DV-003)|4.8.3 Testing for DOM based Cross Site Scripting(OWASP-DV-003) ]]<br>
[[Testing for Cross site flashing   (OWASP-DV-004)|4.8.4 Testing for Cross Site Flashing(OWASP-DV-004) ]]<br>

'''[[Testing for SQL Injection  (OWASP-DV-005)|4.8.5 SQL Injection  (OWASP-DV-005)]]<br>'''
In SQL injection testing, we test if it is possible to inject data into the application so that it executes a user-controlled SQL query in the back-end DB. We find a SQL injection vulnerability if the application uses user input to create SQL queries without proper input validation. A successful exploitation of this class of vulnerability allows an unauthorized user to access or manipulate data in the database. Note that application data often represents the core asset of a company. A SQL Injection attack breaks the following pattern:
Input -> Query SQL == SQL injection<br>
SQL Injection testing is further broken down into:<br>
[[Testing for Oracle |4.8.5.1 Oracle Testing]]<br>
[[Testing for MySQL |4.8.5.2 MySQL Testing ]]<br>
[[Testing for SQL Server |4.8.5.3 SQL Server Testing ]]<br>
[[Testing for MS Access|4.8.5.4 MS Access Testing]]<br>
[[OWASP_Backend_Security_Project_Testing_PostgreSQL|4.8.5.5 Testing PostgreSQL]]<br>

'''[[Testing for LDAP Injection  (OWASP-DV-006) |4.8.6 LDAP Injection  (OWASP-DV-006)]]<br>'''
LDAP injection testing is similar to SQL Injection testing. The differences are that we use the LDAP protocol instead of SQL and that the target is an LDAP Server instead of a SQL Server. 
An LDAP Injection attack breaks the following pattern:<br>
Input -> Query LDAP == LDAP injection<br>

'''[[Testing for ORM Injection   (OWASP-DV-007) |4.8.7 ORM Injection  (OWASP-DV-007)]]<br>'''
ORM injection testing is similar to SQL Injection Testing, as well. In this case, we use a SQL Injection against an ORM-generated data access object model. From the tester's point of view, this attack is virtually identical to a SQL Injection attack. However, the injection vulnerability exists in the code generated by an ORM tool.<br>

'''[[Testing for XML Injection (OWASP-DV-008) |4.8.8 XML Injection (OWASP-DV-008)]]<br>'''
In XML injection testing, we test if it possible to inject a particular XML document into the application. We find an XML injection vulnerability if the XML parser fails to make appropriate data validation.<br>
An XML Injection attack breaks the following pattern:<br>
Input -> XML doc == XML injection<br>

'''[[Testing for SSI Injection  (OWASP-DV-009) |4.8.9 SSI Injection  (OWASP-DV-009)]]<br>'''
Web servers usually give developers the ability to add small pieces of dynamic code inside static HTML pages, without having to deal with full-fledged server-side or client-side languages. This feature is incarnated by Server-Side Includes (SSI) Injection. In SSI injection testing, we test if it is possible to inject into the application data that will be interpreted by SSI mechanisms. A successful exploitation of this vulnerability allows an attacker to inject code into HTML pages or even perform remote code execution.<br>

'''[[Testing for XPath Injection  (OWASP-DV-010) |4.8.10 XPath Injection  (OWASP-DV-010)]]<br>'''
XPath is a language that has been designed and developed primarily to address parts of an XML document. In XPath injection testing, we test if it is possible to inject data into an application so that it executes user-controlled XPath queries. When successfully exploited, this vulnerability may allow an attacker to bypass authentication mechanisms or access information without proper authorization.<br>

'''[[Testing for IMAP/SMTP Injection  (OWASP-DV-011)|4.8.11 IMAP/SMTP Injection  (OWASP-DV-011)]]<br>'''
This threat affects all the applications that communicate with mail servers (IMAP/SMTP), generally webmail applications. In IMAP/SMTP injection testing, we test if it possible to inject arbitrary IMAP/SMTP commands into the mail servers, due to input data not properly sanitized. <br>
An IMAP/SMTP Injection attack breaks the following pattern:<br>
Input -> IMAP/SMTP command == IMAP/SMTP Injection<br>

'''[[Testing for Code Injection  (OWASP-DV-012)|4.8.12 Code Injection  (OWASP-DV-012)]]<br>'''
In code injection testing, we check if it is possible to inject into an application data that will be later executed by the web server.<br>
A Code Injection attack breaks the following pattern:<br>
Input -> malicious Code == Code Injection<br>

'''[[Testing for Command Injection   (OWASP-DV-013)|4.8.13 OS Commanding   (OWASP-DV-013)]]<br>'''
In command injection testing, we will try to inject an OS command through an HTTP request into the application.<br>
An OS Command Injection attack breaks the following pattern:<br>
Input -> OS Command == OS Command Injection<br>

'''[[Testing for Buffer Overflow (OWASP-DV-014)|4.8.14 Buffer overflow (OWASP-DV-014)]]<br>'''
In these tests, we check for different types of buffer overflow vulnerabilities. Here are the testing methods for the common types of buffer overflow vulnerabilities:<br>
[[Testing for Heap Overflow |4.8.14.1 Heap overflow ]]<br>
[[Testing for Stack Overflow |4.8.14.2 Stack overflow ]]<br>
[[Testing for Format String |4.8.14.3 Format string ]]<br>
In general Buffer overflow breaks the following pattern:<br>
Input -> Fixed buffer or format string == overflow<br>

'''[[Testing for Incubated Vulnerability (OWASP-DV-015) |4.8.15 Incubated vulnerability (OWASP-DV-015)]] <br>'''
Incubated testing is a complex testing that needs more than one data validation vulnerability to work.<br>

[[Testing for HTTP Splitting/Smuggling  (OWASP-DV-016)|4.8.16 Testing for HTTP Splitting/Smuggling  (OWASP-DV-016)]]<br>
Describes how to test for an HTTP Exploit, as HTTP Verb, HTTP Splitting, HTTP Smuggling.<br><br>

In every pattern shown, the data should be validated by the application before it's trusted and processed. The goal of our testing is to verify if the application actually performs validation and does not trust its input.